# Chlorophyll Language and Compiler

Chlorophyll language is a language for spatial computation. It is a subset of C with *partition annotation* for pinning data and computation onto computing units (multiple cores). Chlorophyll compiler is a prototype of a *synthesis-aided* compiler. It is built for [GreenArrays 144](http://www.greenarraychips.com/).

Please refer to [Chlorophyll: Synthesis-Aided Compiler for Low-Power Spatial Architectures (PLDI'14)](http://www.eecs.berkeley.edu/~mangpo/www/papers/chlorophyll-pldi14.pdf) for more details on the concept of the *synthesis-aided* compiler and the compilation strategies used in Chlorophyll.

Note: Chlorophyll compiler has only been tested on Linux OS, so it might be incompatible with other operating systems. Please report bugs to mangpo@eecs.berkeley.edu.

# Setting Up

### Requirements

- [Racket](http://download.racket-lang.org)
- [Rosette](http://github.com/emina/rosette)
- [F18A superoptimizer](http://bitbucket.org/rohinmshah/forth-interpreter): install as a local package. In command terminal, type:

```
raco planet link mangpo aforth-optimizer.plt 1 0 path/to/F18A_superoptimizer/repo
```

### Installation

After setting up all the requirements, run
```
make
```

# First Program

Let compile a simple addition program (examples/simple/hello.cll).

```
void main() {
  int@0 a;
  int@1 b;
  int@2 c;
  a = 1; 
  b = 2
  c = a +@2 b;
}
```
This program simply adds 1 and 2, and stores the result in variable *c*. "@" is an annotation for pinning data and computation onto *logical cores*, which are mapped to physical cores later by the compiler. In this example, we assign varaible *a*, *b*, and *c* to different cores, and specify that the addition happens at where *c* is. Thus, logical core 0 and 1 send value of *a* and *b* to logical core 2 respectively.

### Compile
```
./src/chlorophyll examples/simple/hello.cll
```

The compiler will generate directory `examples/simple/output-hello`, in which contains many files. If everything goes well, you should see the final arrayForth program geneated by the compiler, `examples/simple/output-hello/hello-noopt2.aforth`.

### Compile -o
Compile with `-o` to turn the superoptimizer (optimizing back-end code generator) on. Note that the compiler is much slower when compiling with `-o`, but the output program is more efficient. The superoptimizer caches its outputs, so if you have already compiled a program with `-o`, the subsequent compilation of the same program will be fast. The final optimized arrayForth program is `examples/simple/output-hello/hello.aforth`. 

The compiler invokes multiple superoptimizers to optimize code of multiple GA nodes in parallel. The default number of threads used is 4. To change the number of threads, in `src/header.rkt`, modiy the following line:
```
(define procs 4)
```
Only compiling with `-o` when you are certian that your progam is corect.

### Other Compiler Options

The default number of rows of nodes is 2, and the default number of columns of nodes is 3. Modify the number of rows and columns using `-r` and `-c` options. `--heu-partition` uses a heuristic partitioner (greedy algorithm) instead of the default synthesizing partitioner.  Note that the heuristic partitioner is much faster than the synthesizing partitioner, but the output partitioning from the heuristic partitioner is less optimal.

To view all compiler options and the default settings, run
```
./src/chlorophyll -h
```

### Testing Your Programs
To facilitate testing, in the testing mode, we introduce `in()` and `out()` constructs that read from standard input and write to standard output respectively. In `examples/simple/hello-io.cll`, we modify `examples/simple/hello.cll` to read *a* and *b* from standard input, and write *c* to stardard output.

You can test your implementation before fully compiling the program by running
```
./src/chlorophyll-test examples/simple/hello-io.cll 2
```

The second argument is the input data file in `testdata` directory. In this case, `testdata/2` is the input data, which contains two integers, since our program takes two intgers from standard input. `chlorophyll-test` generates
- **examples/simple/output-hello/hello-io_seq.cpp**, a sequential C++ program that is semantically equivalent to the source program, and
- **examples/simple/output-hello/hello-io.cpp**, a multi-threaded C++ program that simulates mutiple GA nodes and is semantically equivalent to the source program.

Given `testdata/2` as the input, the outputs of hello-io_seq.cpp and hello-io.cpp are `testdata/out/hello-io_2.out` and `testdata/out/hello-io_2.tmp`. `chlorophyll-test` displays **PASSED** at the end if the two output data files are the same, or displays **FAILED** otherwise. We expect `chlorophyll-test` to always display **PASSED**. If not, there is a problem with the compiler (not your implementation). In such case, please file a bug report.

If all go well, you can refer to either `hello-io_2.out` or `hello-io_2.tmp` as the output from your implementation.

##### in()/out()
If you left `in()` and `out()` in your program and compile all the way down to arrayForth code. `in()` and `out()` correspond to reading from and writing to I/O pin, respectively. However, keep in mind that not all nodes have I/O pins.

### Forth to colorForth
`cforth_tools` directory contains scripts for converting the generated arrayForth program in text file into colorForth binary compatible with [GreenArrays 144 IDE](http://www.greenarraychips.com/home/support/download-02b.html). 

Starting from `template.cfs`, replace block 790, 792, and 800 with the generated code from the compiler (e.g. `examples/simple/output-hello/hello-noopt2.aforth`). Then, change the following line of `cforth_tools/Makefile` to match the .cfs file you want to convert.
```
NEW_CFS=template.cfs
```

Under `cforth_tools` directory, run
```
make clean
make install
```
Copy the generated `OkadWork.cf` to GreenArrays 144 IDE directory. Compile the program in the IDE, and modify block 792 so that all nodes start executing at the appropriate words (where main functions start) and not 0, which is the default. For `hello-noopt2.aforth`, all main functions are at 0, so we do not have to modify block 792. Now, you can run the GreenArrays 144 softsim.

# Compilation Strategies

Chlorophyll compiler consists the following components.
1. **Partitioner** partitions data and computations onto logical cores.
2. **Layout** maps logical cores to physical cores and determines the routing between cores.
3. **Code seperator** seperates the program into multiple program fragments that fit in GA cores and inserts communication code at the appropriate places in the program fragments.
4. **Code generator** generates arrayForth code. Our code generator uses a superoptimization technique to optimize code.

When you compile `xxx.cll`, the compiler will generate a directory `output-xxx` which contains
- **xxx.part**: output from the partitioner, a fully partitioned xxx program (all varaibles and operaters are annoatated with logical cores)
- **xxx.dat** and **xxx.graph**: inputs to the layout
- **xxx.layout**: output from the layout
- **xxx-gen1.rkt** and **xxx-gen2.rkt**: outputs from the code separator as Racket objects. When we discover repeating sequences of instructions, we define a function that executes such sequence of instructions, and replace each of those repeating sequences with a function call. *xxx-gen2.rkt* is the version that replaces the repeating sequences with function calls.
- **xxx.cpp**: output of compling *xxx-gen1.rkt* into C++ programs. Each thread represents each GA core. *xxx.cpp* can be compiled to an executable using `g++ -pthread -std=c++0x xxx.cpp`.
- **xxx-noopt1.rkt** and **xxx-noopt2.rkt**: outputs from compiling *xxx-gen1.rkt* and *xxx-gen2.rkt* to arrayForth respectively. xxx-noopt1.rkt and xxx-noopt2.rkt are generated without superoptimization.
- **xxx.aforth**: the final optimized arrayForth program from the superoptimizer.
- many more files generated during superoptimization process.

# Language Constructs

### Partition Annotation

You can choose to annotate all varaibles and operaters with partitions (logical cores) they belong to, to annotate parts of them, or to not annotate the program at all.

For example, if we modify `examples/simple/hello.cll` by removing the parittion annotations of variable *a* and *b* as follows:

```
void main() {
  int a;
  int b;
  int@2 c;
  a = 1; 
  b = 2;
  c = a +@2 b;
}
```

The partitioner will complete those annotations automatically. In this example, the entire program can fit in one core, so the partitioner will assign both *a* and *b* to logical core 2 as it tries to minimize communication between cores. You can check this by rerunning the compiler and look at `example/simple/output-hello/hello.part`. 

Note that the partitioner can be very slow if it partitions a large program without much annotation. When it is very slow, you can try to annotation more, or use `--hue-partition` option when compiling.

### Data Type

Chlorophyll currently supports only one primitive data type, `int`, 18-bit integer, as GreenArrays is a 18-bit architecture. Chlorophyll supports tuples and arrays of `int`.

##### Tuples
Define *x* as a tuple of 3 elements whose elements live at logical core 0, 1, and 2:
```
int::3@(0,1,2) x;
```

Reference to the first element in tuple *x*:
```
x::0
```

See `examples/simple/function-pair.cll` for an example program with tuples.

##### Arrays

Non-distribued array:
```
int@6 k[10];
```

Distributed array:
```
int@{[0:5]=6, [5:10]=7} k[10];
```
k[0] to k[4] are on core 6, and k[5] to k[9] are on core 7. Note that the begining of the range is inclusive, while the end of the range is exclusive.

Distributed array of tuples:
```
int::2@{[0:10]=(6,7)} k[10];
```
All first elements of the tuples are in core 6, and all second elements of the tuples are in core 7.

### Parallel Map and Reduce

Parallel map:
```
output_array = map(func, input_array1, input_array2, ...);
```

Parallel reduce:
```
output_var = reduce(func, init, input_array);
```

`example/mapreduce` contains example programs that use map and reduce constructs.

# Bugs and Features
For a bug report or a feature request, please contact mangpo@eecs.berkeley.edu.
