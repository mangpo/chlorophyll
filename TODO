TODO
1) unext

2) 17 not 3!
{block 1016}
( -) # 403 ( mem 5) 0 org | cr
0 , 25185 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 24 , 0 , 0 , 0 , | br
: store 17 b! !b ; | cr
: sumrotate = $0 325 b! dup 0 a! !b !+ @b left b! !b = $0 ; | cr
: 85rep = $0 18 b! !b | cr
  15 for | cr
    3 ( 17 ) b! @b 1 . + b! @b sumrotate 17 a! @+ @+ . + 15 and store next = $0 ; | cr
: main = $0 
  0 store 1 85rep 
  1 store 5 85rep 
  5 store 3 85rep 
  0 store 7 85rep warm = $0 ; | cr

3) replace 0 with dup dup or
4)
;(optimize "65535 and 4 b! !b 5 b! @b 65535" 
;          #:constraint (constraint s t memory) #:f18a #f
;          #:mem 6 #:num-bits 18)
; i want: 65535 dup push . and 4 a! . !+ @ pop
5) temp order for return
6) test md2

- measure time & energy
- more benchmarks
  = vs expert
  = vs unopt
  = vs manual code
- call rohin's compiler to get program size
  = if size > 64 words -> define-repeating-code for shorter seq
- connect to rohin's interpreter
  = left, right, up, down
  = 0 , 0 , 0 ,
- or tikhon's
  = word for starting to execute
- stat report

- redundant temp for funccall
- kill z3 when user break happens
- nop is less than everything, @ < @+
- 3 a! @ 32 - 1 . + . + 0 . + a! @
  = implement an abstract interpreter to just figure how many send and recv we need
  = no need to generate first pair from the interpreter

- reset rosette when solving new problem (see compiler.rkt)
- known type interpreter
  = for-array2-error.cll should have compile error: other variable (e.g. i) can't be at the same place ast clustered array
- data type check (x[i] + y) when y is array
- visitor-divider can't handle nested indexes (eg. +@place(x[i*n+j]))

- refactoring interpretor & flow & comminsert
- topological sort
- recursion
- general for?
- for-array-fancy.cll
- do we have to support int@any x?
  might need one more pass to get inferred place (e.g. @any)

FASTER PARTITIONER
- infer each function first (see issue about racket)
- incremental solving on num-msg

ISSUE ABOUT RACKET
- branch debug
- email emina about smaller example
- after the error is gone, do perf test again (partial vs no partial)

BETTER ESTIMATION
- symbolic set or lower space to 4
  vector v of set s
  (vector-ref v i) -> (ite cond (set *) (set * /))
  (set-add (vector-ref v i) %) => ERROR

MEMO
- same VarDecl => same sym-place!!!

BENCHMARKS
- insertion sort
- add
- md5 (RUNNING: no partial, RUN: partial)
- matrix multiply (2D?)

RUN
- 1D convolution (better analysis)
- prefixsum (better analysis)
- ssd (multiple copies) in laptop?

future
- blackscholes (float, log, exp)
- mergesort (function, recursion)
- FFT
